% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bitset.R
\name{Bitset}
\alias{Bitset}
\title{A Bitset Class}
\description{
This is a data structure that compactly stores the presence of
integers in some finite set (\code{max_size}), and can
efficiently perform set operations (union, intersection, complement, symmetric
difference, set difference).
WARNING: All operations are in-place so please use \code{$copy}
if you would like to perform an operation without destroying your current bitset.

This class is defined as a named list for performance reasons, but for most
intents and purposes it behaves just like an R6 class.
}
\section{Methods}{

\if{html}{\out{<hr>}}
\subsection{Method \code{new()}}{
create a bitset.
\subsection{Usage}{
\preformatted{Bitset$new(size, from)}
}
\subsection{Arguments}{
\describe{
\item{\code{size}}{the size of the bitset.}
\item{\code{from}}{pointer to an existing IterableBitset to use; if \code{NULL} make empty bitset, otherwise copy existing bitset.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{insert()}}{
insert into the bitset.
\subsection{Usage}{
\preformatted{Bitset$insert(v)}
}
\subsection{Arguments}{
\describe{
\item{\code{v}}{an integer vector of elements to insert.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{remove()}}{
insert from the bitset.
\subsection{Usage}{
\preformatted{Bitset$remove(v)}
}
\subsection{Arguments}{
\describe{
\item{\code{v}}{an integer vector of elements (not indices) to remove.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{clear()}}{
clear the bitset.
\subsection{Usage}{
\preformatted{Bitset$clear()}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{size()}}{
get the number of elements in the set.
\subsection{Usage}{
\preformatted{Bitset$size()}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{or()}}{
to "bitwise or" or union two bitsets.
\subsection{Usage}{
\preformatted{Bitset$or(other)}
}
\subsection{Arguments}{
\describe{
\item{\code{other}}{the other bitset.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{and()}}{
to "bitwise and" or intersect two bitsets.
\subsection{Usage}{
\preformatted{Bitset$and(other)}
}
\subsection{Arguments}{
\describe{
\item{\code{other}}{the other bitset.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{not()}}{
to "bitwise not" or complement a bitset.
\subsection{Usage}{
\preformatted{Bitset$not(inplace)}
}
\subsection{Arguments}{
\describe{
\item{\code{inplace}}{whether to overwrite the current bitset, default = TRUE}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{xor()}}{
to "bitwise xor" get the symmetric difference of two bitset (keep elements in either bitset but not in their intersection).
\subsection{Usage}{
\preformatted{Bitset$xor(other)}
}
\subsection{Arguments}{
\describe{
\item{\code{other}}{the other bitset.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{set_difference()}}{
Take the set difference of this bitset with another (keep elements of this bitset which are not in \code{other})
\subsection{Usage}{
\preformatted{Bitset$set_difference(other)}
}
\subsection{Arguments}{
\describe{
\item{\code{other}}{the other bitset.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{sample()}}{
sample a bitset.
\subsection{Usage}{
\preformatted{Bitset$sample(rate)}
}
\subsection{Arguments}{
\describe{
\item{\code{rate}}{the success probability for keeping each element, can be a single value for all elements or a vector of unique probabilities for keeping each element.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{choose()}}{
choose k random items in the bitset.
\subsection{Usage}{
\preformatted{Bitset$choose(k)}
}
\subsection{Arguments}{
\describe{
\item{\code{k}}{the number of items in the bitset to keep. The selection of these k items from N total items in the bitset is random, and k should be chosen such that \eqn{0 \le k \le N}.}
}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{copy()}}{
returns a copy of the bitset.
\subsection{Usage}{
\preformatted{Bitset$copy()}
}
}
\if{html}{\out{<hr>}}
\subsection{Method \code{to_vector()}}{
return an integer vector of the elements stored in this bitset.
\subsection{Usage}{
\preformatted{Bitset$to_vector()}
}
}
}

